```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing and Rotation</title>
    <style>canvas { border: 1px solid black; }</style>
</head>
<body>
    <canvas id="drawingCanvas" width="500" height="500"></canvas>
    <button id="rotateXPositiveButton">↓回転</button>
    <button id="rotateXNegativeButton">↑回転</button>
    <div id="xRotationAngle">X回転角: 0度</div>
    <button id="rotateYNegativeButton">←回転</button>
    <button id="rotateYPositiveButton">→回転</button>
    <div id="yRotationAngle">Y回転角: 0度</div>
    <button id="resetButton">線を書き直す</button>
    <div id="lineLength">線の長さ: 0px</div>
    <button id="mirrorSymmetryResetButton">対称線リセット</button>
    <button id="unfoldButton">展開図作成</button>
    <canvas id="unfoldCanvas" width="500" height="500"></canvas>

    <script>
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingContext = drawingCanvas.getContext('2d');
        const centerX = drawingCanvas.width / 2;
        const centerY = drawingCanvas.height / 2;

        const unfoldCanvas = document.getElementById('unfoldCanvas');
        const unfoldContext = unfoldCanvas.getContext('2d');
        const unfoldCenterX = unfoldCanvas.width / 2;
        const unfoldCenterY = unfoldCanvas.height / 2;

        let isDrawing = false;
        let points = [];
        let angleX = 0;
        let angleY = 0;
        let currentLine = [];
        let draggedPoint = null;
        let draggedMirrorPoint = null;
        let draggedMidPoint = null;
        let lastPoint = null;
        let mirrorPoints = [];
        let midPoints = [];
        let centerLine = [];
        let surfaceDisplay = false;

        drawingCanvas.addEventListener('mousedown', event => {
            if (!currentLine.length) {
                isDrawing = true;
                const startPoint = { x: event.offsetX - centerX, y: event.offsetY - centerY, z: 0 };
                points.push(startPoint);
                currentLine.push(startPoint);
                drawPoint(startPoint);
                lastPoint = startPoint;
            } else {
                const clickedPoint = getClickedPoint(event.offsetX, event.offsetY);
                if (clickedPoint) {
                    draggedPoint = clickedPoint;
                } else {
                    const clickedMirrorPoint = getClickedMirrorPoint(event.offsetX, event.offsetY);
                    if (clickedMirrorPoint) {
                        draggedMirrorPoint = clickedMirrorPoint;
                    } else {
                        const clickedMidPoint = getClickedMidPoint(event.offsetX, event.offsetY);
                        if (clickedMidPoint) {
                            draggedMidPoint = clickedMidPoint;
                        } else {
                            const newPointOnLine = getNewPointOnLine(event.offsetX, event.offsetY);
                            if (newPointOnLine) {
                                points.splice(newPointOnLine.index, 0, newPointOnLine.point);
                                redrawCanvas();
                            }
                        }
                    }
                }
            }
        });

        drawingCanvas.addEventListener('mousemove', event => {
            if (isDrawing) {
                const x = event.offsetX - centerX;
                const y = event.offsetY - centerY;
                const endPoint = { x, y, z: 0 };
                if (lastPoint && calculateDistance(lastPoint, endPoint) >= 50) {
                    points.push(endPoint);
                    drawPoint(endPoint);
                    drawLine(lastPoint, endPoint);
                    lastPoint = endPoint;
                    updateLineLength();
                }
            } else if (draggedPoint) {
                draggedPoint.x = event.offsetX - centerX;
                draggedPoint.y = event.offsetY - centerY;
                if (points.indexOf(draggedPoint) === 0) {
                    points[0] = draggedPoint;
                    mirrorPoints[0] = getMirrorPoint(draggedPoint, points[0], points[points.length - 1]);
                    midPoints[0] = getMidPoint(draggedPoint, mirrorPoints[0]);
                } else if (points.indexOf(draggedPoint) === points.length - 1) {
                    points[points.length - 1] = draggedPoint;
                    mirrorPoints[mirrorPoints.length - 1] = getMirrorPoint(draggedPoint, points[0], points[points.length - 1]);
                    midPoints[midPoints.length - 1] = getMidPoint(draggedPoint, mirrorPoints[mirrorPoints.length - 1]);
                }
                redrawCanvas();
                updateLineLength();
            } else if (draggedMirrorPoint) {
                draggedMirrorPoint.x = event.offsetX - centerX;
                draggedMirrorPoint.y = event.offsetY - centerY;
                redrawCanvas();
                updateLineLength();
            } else if (draggedMidPoint) {
                draggedMidPoint.x = event.offsetX - centerX;
                draggedMidPoint.y = event.offsetY - centerY;
                redrawCanvas();
                updateLineLength();
            }
        });

        drawingCanvas.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                if (points.length > 1) {
                    const startPoint = points[0];
                    const endPoint = points[points.length - 1];
                    createMirrorSymmetry(startPoint, endPoint);
                    createMidPoints(startPoint, endPoint);
                }
                lastPoint = null;
                surfaceDisplay = true;
            }
            draggedPoint = null;
            draggedMirrorPoint = null;
            draggedMidPoint = null;
            redrawCanvas();
        });

        document.getElementById('rotateXPositiveButton').addEventListener('click', () => rotatePointsX(10));
        document.getElementById('rotateXNegativeButton').addEventListener('click', () => rotatePointsX(-10));
        document.getElementById('rotateYPositiveButton').addEventListener('click', () => rotatePointsY(10));
        document.getElementById('rotateYNegativeButton').addEventListener('click', () => rotatePointsY(-10));

        document.getElementById('resetButton').addEventListener('click', () => {
            surfaceDisplay = false;
            points = [];
            currentLine = [];
            angleX = 0;
            angleY = 0;
            mirrorPoints = [];
            midPoints = [];
            centerLine = [];
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            unfoldContext.clearRect(0, 0, unfoldCanvas.width, unfoldCanvas.height);
            document.getElementById('xRotationAngle').innerText = `X回転角: 0度`;
            document.getElementById('yRotationAngle').innerText = `Y回転角: 0度`;
            document.getElementById('lineLength').innerText = `線の長さ: 0px`;
        });

        document.getElementById('mirrorSymmetryResetButton').addEventListener('click', () => {
            if (points.length > 1) {
                const startPoint = points[0];
                const endPoint = points[points.length - 1];
                createMirrorSymmetry(startPoint, endPoint);
                createMidPoints(startPoint, endPoint);
            }
        });

        document.getElementById('unfoldButton').addEventListener('click', () => {
            if (points.length > 1) {
                createUnfoldedView();
            }
        });

        function rotatePointsX(angleIncrement) {
            angleX = (angleX + angleIncrement) % 360;
            const angleXInRadians = angleIncrement * Math.PI / 180;
            points = points.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return { x: point.x, y, z };
            });
            mirrorPoints = mirrorPoints.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return { x: point.x, y, z };
            });
            midPoints = midPoints.map(point => {
                const y = point.y * Math.cos(angleXInRadians) - point.z * Math.sin(angleXInRadians);
                const z = point.y * Math.sin(angleXInRadians) + point.z * Math.cos(angleXInRadians);
                return { x: point.x, y, z };
            });
            redrawCanvas();
            document.getElementById('xRotationAngle').innerText = `X回転角: ${angleX}度`;
            updateLineLength();
        }

        function rotatePointsY(angleIncrement) {
            angleY = (angleY + angleIncrement) % 360;
            const angleYInRadians = angleIncrement * Math.PI / 180;
            points = points.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return { x, y: point.y, z };
            });
            mirrorPoints = mirrorPoints.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return { x, y: point.y, z };
            });
            midPoints = midPoints.map(point => {
                const x = point.x * Math.cos(angleYInRadians) - point.z * Math.sin(angleYInRadians);
                const z = point.x * Math.sin(angleYInRadians) + point.z * Math.cos(angleYInRadians);
                return { x, y: point.y, z };
            });
            redrawCanvas();
            document.getElementById('yRotationAngle').innerText = `Y回転角: ${angleY}度`;
            updateLineLength();
        }

        function drawPoint(point, color = 'black') {
            const size = Math.max(1, (10 - point.z / 20) * 0.5);
            drawingContext.beginPath();
            drawingContext.arc(point.x + centerX, point.y + centerY, size, 0, 2 * Math.PI);
            drawingContext.fillStyle = color;
            drawingContext.globalAlpha = 0.5;
            drawingContext.fill();
            drawingContext.globalAlpha = 1.0;
        }

        function drawLine(start, end, color = 'black') {
            drawingContext.beginPath();
            drawingContext.moveTo(start.x + centerX, start.y + centerY);
            drawingContext.lineTo(end.x + centerX, end.y + centerY);
            drawingContext.strokeStyle = color;
            drawingContext.stroke();
        }

        function getClickedPoint(x, y) {
            for (const point of points) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerY);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function getClickedMirrorPoint(x, y) {
            for (const point of mirrorPoints) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerY);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function getClickedMidPoint(x, y) {
            for (const point of midPoints) {
                const dx = x - (point.x + centerX);
                const dy = y - (point.y + centerX);
                if (Math.sqrt(dx * dx + dy * dy) < 5) return point;
            }
            return null;
        }

        function getNewPointOnLine(x, y) {
            const clickedX = x - centerX;
            const clickedY = y - centerY;
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];
                const distanceToLine = calculatePointToLineDistance(clickedX, clickedY, start, end);
                if (distanceToLine < 5) {
                    const t = ((clickedX - start.x) * (end.x - start.x) + (clickedY - start.y) * (end.y - start.y)) / ((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                    const newX = start.x + t * (end.x - start.x);
                    const newY = start.y + t * (end.y - start.y);
                    return { point: { x: newX, y: newY, z: 0 }, index: i + 1 };
                }
            }
            return null;
        }

        function calculatePointToLineDistance(px, py, start, end) {
            const A = px - start.x;
            const B = py - start.y;
            const C = end.x - start.x;
            const D = end.y - start.y;
            const dot = A * C + B * D;
            const lengthSquared = C * C + D * D;
            const param = dot / lengthSquared;
            let xx, yy;
            if (param < 0 || (start.x === end.x && start.y === end.y)) {
                xx = start.x;
                yy = start.y;
            } else if (param > 1) {
                xx = end.x;
                yy = end.y;
            } else {
                xx = start.x + param * C;
                yy = start.y + param * D;
            }
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function calculateDistance(point1, point2) {
            return Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2 + (point2.z - point1.z) ** 2);
        }

        function redrawCanvas() {
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            for (let i = 0; i < points.length; i++) {
                drawPoint(points[i]);
                if (i > 0) drawLine(points[i - 1], points[i]);
            }
            for (let i = 0; i < mirrorPoints.length; i++) {
                drawPoint(mirrorPoints[i], 'red');
                if (i > 0) drawLine(mirrorPoints[i - 1], mirrorPoints[i], 'red');
            }
            for (let i = 0; i < midPoints.length; i++) {
                drawPoint(midPoints[i], 'blue');
                if (i > 0) drawLine(midPoints[i - 1], midPoints[i], 'blue');
            }
            if (points.length > 1) drawLine(points[0], points[points.length - 1]);
            if (surfaceDisplay && points.length > 1) {
                createCenterLine();
                drawSurface();
            }
        }

        function updateLineLength() {
            if (points.length > 1) {
                const start = points[0];
                const end = points[points.length - 1];
                const length = calculateDistance(start, end);
                document.getElementById('lineLength').innerText = `線の長さ: ${length.toFixed(2)}px`;
            } else {
                document.getElementById('lineLength').innerText = `線の長さ: 0px`;
            }
        }

        function createMirrorSymmetry(startPoint, endPoint) {
            mirrorPoints = points.map(point => getMirrorPoint(point, startPoint, endPoint));
            redrawCanvas();
        }

        function getMirrorPoint(point, startPoint, endPoint) {
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const a = (dx * dx - dy * dy) / (dx * dx + dy * dy);
            const b = 2 * dx * dy / (dx * dx + dy * dy);
            const x = a * (point.x - startPoint.x) + b * (point.y - startPoint.y) + startPoint.x;
            const y = b * (point.x - startPoint.x) - a * (point.y - startPoint.y) + startPoint.y;
            return { x: x, y: y, z: point.z };
        }

        function createMidPoints(startPoint, endPoint) {
            midPoints = points.map((point, index) => {
                const mirrorPoint = mirrorPoints[index];
                const midX = (point.x + mirrorPoint.x) / 2;
                const midY = (point.y + mirrorPoint.y) / 2;
                const midZ = (point.z + mirrorPoint.z) / 2;
                return { x: midX, y: midY, z: midZ };
            });
            redrawCanvas();
        }

        function createCenterLine() {
            centerLine = midPoints.map(point => ({ ...point }));
        }

        function drawSurface() {
            for (let i = 0; i < points.length; i++) {
                if (i > 0) {
                    drawLine(points[i], midPoints[i], 'gray');
                    drawLine(mirrorPoints[i], centerLine[i], 'gray');
                    fillQuadrilateral(points[i - 1], midPoints[i - 1], midPoints[i], points[i], 'rgba(211, 211, 211, 0.5)');
                    fillQuadrilateral(mirrorPoints[i - 1], centerLine[i - 1], centerLine[i], mirrorPoints[i], 'rgba(211, 211, 211, 0.5)');
                }
            }
        }

        function fillQuadrilateral(p1, p2, p3, p4, color) {
            drawingContext.beginPath();
            drawingContext.moveTo(p1.x + centerX, p1.y + centerY);
            drawingContext.lineTo(p2.x + centerX, p2.y + centerY);
            drawingContext.lineTo(p3.x + centerX, p3.y + centerY);
            drawingContext.lineTo(p4.x + centerX, p4.y + centerY);
            drawingContext.closePath();
            drawingContext.fillStyle = color;
            drawingContext.fill();
        }

        function getMidPoint(point1, point2) {
            return {
                x: (point1.x + point2.x) / 2,
                y: (point1.y + point2.y) / 2,
                z: (point1.z + point2.z) / 2
            };
        }

        function createUnfoldedView() {
            unfoldContext.clearRect(0, 0, unfoldCanvas.width, unfoldCanvas.height);

            // Copy points from drawingCanvas to unfoldCanvas
            const points2 = points.map(point => ({ ...point }));
            const mirrorPoints2 = mirrorPoints.map(point => ({ ...point }));
            const midPoints2 = midPoints.map(point => ({ ...point }));
            const centerLine2 = centerLine.map(point => ({ ...point }));

            // Rotate all copied points so that both start and end points have z=0
            rotateAllCopiedPointsToZAxis(points2, mirrorPoints2, midPoints2, centerLine2);

            // Draw original points and lines on unfoldCanvas
            points.forEach(point => {
                drawUnfoldedPoint(point);
            });

            for (let i = 0; i < points.length - 1; i++) {
                drawUnfoldedLine(points[i], points[i + 1]);
            }

            mirrorPoints.forEach(point => {
                drawUnfoldedPoint(point, 'red');
            });

            for (let i = 0; i < mirrorPoints.length - 1; i++) {
                drawUnfoldedLine(mirrorPoints[i], mirrorPoints[i + 1], 'red');
            }

            midPoints.forEach(point => {
                drawUnfoldedPoint(point, 'blue');
            });

            for (let i = 0; i < midPoints.length - 1; i++) {
                drawUnfoldedLine(midPoints[i], midPoints[i + 1], 'blue');
            }

            // Draw lines between points and midPoints
            for (let i = 0; i < points.length; i++) {
                drawUnfoldedLine(points[i], midPoints[i], 'gray');
            }

            // Draw lines between mirrorPoints and centerLine
            for (let i = 0; i < mirrorPoints.length; i++) {
                drawUnfoldedLine(mirrorPoints[i], centerLine[i], 'gray');
            }

            // Draw copied points and lines on unfoldCanvas
            points2.forEach(point => {
                drawUnfoldedPoint(point, 'green');
            });

            for (let i = 0; i < points2.length - 1; i++) {
                drawUnfoldedLine(points2[i], points2[i + 1], 'green');
            }

            mirrorPoints2.forEach(point => {
                drawUnfoldedPoint(point, 'orange');
            });

            for (let i = 0; i < mirrorPoints2.length - 1; i++) {
                drawUnfoldedLine(mirrorPoints2[i], mirrorPoints2[i + 1], 'orange');
            }

            midPoints2.forEach(point => {
                drawUnfoldedPoint(point, 'purple');
            });

            for (let i = 0; i < midPoints2.length - 1; i++) {
                drawUnfoldedLine(midPoints2[i], midPoints2[i + 1], 'purple');
            }

            // Draw lines between copied points and midPoints
            for (let i = 0; i < points2.length; i++) {
                drawUnfoldedLine(points2[i], midPoints2[i], 'gray');
            }

            // Draw lines between copied mirrorPoints and centerLine
            for (let i = 0; i < mirrorPoints2.length; i++) {
                drawUnfoldedLine(mirrorPoints2[i], centerLine2[i], 'gray');
            }

            // Create and draw quadrilaterals on the left side of the unfoldCanvas
            let offsetX =  -50;
            let offsetY = -50;
            let remainingQuads = [];

            for (let i = 0; i < points2.length - 1; i++) {
                const p1 = points2[i];
                const p2 = points2[i + 1];
                const m1 = midPoints2[i];
                const m2 = midPoints2[i + 1];

                const quad = [
                    { x: p1.x, y: p1.y, z: 0 },
                    { x: p2.x, y: p2.y, z: 0 },
                    { x: m2.x, y: m2.y, z: 0 },
                    { x: m1.x, y: m1.y, z: 0 }
                ];

                remainingQuads.push(quad);
            }

            remainingQuads.sort((a, b) => Math.min(a[0].y, a[1].y, a[2].y, a[3].y) - Math.min(b[0].y, b[1].y, b[2].y, b[3].y));

            while (remainingQuads.length > 0) {
                const quad = remainingQuads.shift();
                const minY = Math.min(quad[0].y, quad[1].y, quad[2].y, quad[3].y);
                const offsetYAdjusted = offsetY - minY;

                const movedQuad = quad.map(point => ({
                    x: point.x + offsetX,
                    y: point.y + offsetYAdjusted,
                    z: point.z
                }));

                fillUnfoldedQuadrilateral(movedQuad, 'rgba(211, 211, 211, 0.5)');
                offsetY += Math.max(calculateDistance(movedQuad[0], movedQuad[1]), calculateDistance(movedQuad[2], movedQuad[3])) + 10;
            }

            // Create and draw quadrilaterals on the right side of the unfoldCanvas
            offsetX = 50;
            offsetY = -50;
            remainingQuads = [];

            for (let i = 0; i < mirrorPoints2.length - 1; i++) {
                const p1 = mirrorPoints2[i];
                const p2 = mirrorPoints2[i + 1];
                const m1 = centerLine2[i];
                const m2 = centerLine2[i + 1];

                const quad = [
                    { x: p1.x, y: p1.y, z: 0 },
                    { x: p2.x, y: p2.y, z: 0 },
                    { x: m2.x, y: m2.y, z: 0 },
                    { x: m1.x, y: m1.y, z: 0 }
                ];

                remainingQuads.push(quad);
            }

            remainingQuads.sort((a, b) => Math.min(a[0].y, a[1].y, a[2].y, a[3].y) - Math.min(b[0].y, b[1].y, b[2].y, b[3].y));

            while (remainingQuads.length > 0) {
                const quad = remainingQuads.shift();
                const minY = Math.min(quad[0].y, quad[1].y, quad[2].y, quad[3].y);
                const offsetYAdjusted = offsetY - minY;

                const movedQuad = quad.map(point => ({
                    x: point.x + offsetX,
                    y: point.y + offsetYAdjusted,
                    z: point.z
                }));

                fillUnfoldedQuadrilateral(movedQuad, 'rgba(211, 211, 211, 0.5)');
                //offsetX += Math.max(calculateDistance(movedQuad[0], movedQuad[1]), calculateDistance(movedQuad[2], movedQuad[3])) + 50;
                offsetY += 10;
            }
        }

        function drawUnfoldedPoint(point, color = 'black') {
            const size = Math.max(1, (10 - point.z / 20) * 0.5);
            unfoldContext.beginPath();
            unfoldContext.arc(point.x + unfoldCenterX, point.y + unfoldCenterY, size, 0, 2 * Math.PI);
            unfoldContext.fillStyle = color;
            unfoldContext.globalAlpha = 0.5;
            unfoldContext.fill();
            unfoldContext.globalAlpha = 1.0;
        }

        function drawUnfoldedLine(start, end, color = 'black') {
            unfoldContext.beginPath();
            unfoldContext.moveTo(start.x + unfoldCenterX, start.y + unfoldCenterY);
            unfoldContext.lineTo(end.x + unfoldCenterX, end.y + unfoldCenterY);
            unfoldContext.strokeStyle = color;
            unfoldContext.stroke();
        }

        function fillUnfoldedQuadrilateral(quad, color) {
            unfoldContext.beginPath();
            unfoldContext.moveTo(quad[0].x + unfoldCenterX, quad[0].y + unfoldCenterY);
            unfoldContext.lineTo(quad[1].x + unfoldCenterX, quad[1].y + unfoldCenterY);
            unfoldContext.lineTo(quad[2].x + unfoldCenterX, quad[2].y + unfoldCenterY);
            unfoldContext.lineTo(quad[3].x + unfoldCenterX, quad[3].y + unfoldCenterY);
            unfoldContext.closePath();
            unfoldContext.fillStyle = color;
            unfoldContext.fill();
        }

        function rotateAllCopiedPointsToZAxis(points2, mirrorPoints2, midPoints2, centerLine2) {
            if (points2.length < 2) return;

            const startPoint = points2[0];
            const endPoint = points2[points2.length - 1];

            const angle = Math.atan2(endPoint.z - startPoint.z, endPoint.y - startPoint.y);
            const angleToRotate = -angle;

            const rotatePoint = (point) => {
                const y = point.y * Math.cos(angleToRotate) - point.z * Math.sin(angleToRotate);
                const z = point.y * Math.sin(angleToRotate) + point.z * Math.cos(angleToRotate);
                return { x: point.x, y, z };
            };

            points2 = points2.map(rotatePoint);
            mirrorPoints2 = mirrorPoints2.map(rotatePoint);
            midPoints2 = midPoints2.map(rotatePoint);
            centerLine2 = centerLine2.map(rotatePoint);

            // Adjust points to maintain distances and set z=0
            adjustPointsToZAxis(points2);
            adjustPointsToZAxis(mirrorPoints2);
            adjustPointsToZAxis(midPoints2);
            adjustPointsToZAxis(centerLine2);
        }

        function adjustPointsToZAxis(points) {
            for (let i = 1; i < points.length; i++) {
                const prevPoint = points[i - 1];
                const currentPoint = points[i];
                const distance = calculateDistance(prevPoint, currentPoint);
                const angle = Math.atan2(currentPoint.y - prevPoint.y, currentPoint.x - prevPoint.x);
                currentPoint.x = prevPoint.x + distance * Math.cos(angle);
                currentPoint.y = prevPoint.y + distance * Math.sin(angle);
                currentPoint.z = 0;
            }
        }
    </script>
</body>
</html>
```
